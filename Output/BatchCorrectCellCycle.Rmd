---
title: "scRNASeq data analysis-batch correction/cell cycle"
author: "Feng, Feng"
date: "`r Sys.Date()`"
header-includes:
    - \usepackage{setspace}\doublespacing
output: 
    pdf_document:
        fig_caption: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  tidy=FALSE,
  engine='R'
)
```
# 1. Purpose
- Rerun and experiment with different batch correction methods,
since original data generated by Erik seem a little "off". 
The following things will be tried:
	+ no batch correction
	+ batch corrected at subject level
	+ batch corrected at cell population level
	+ batch corrected using the MNN algorithm (R "batchelor" package)
- Run cell cycle scoring	

# 2. Data input
The data input were generated by 10x Genomics Cellranger with all 6 subjects, 
and each subject with 3 cell populatoins. The data were on dropbox.

** Note **: to run this Rmd file, you need to revised the data
directory information in the following section.

```{r, eval=T}  
#Note: the original code were in file:///home/feng/Feng/hg/scravid2/CVIDagg6_SeuratPipeline_FF_v1.0.R
#library
library(Seurat)
library(dplyr)
library(Matrix)
library(gdata)
library(patchwork)
library(cowplot)
library(stringr)
library(ggpubr)
library(batchelor)
library(SeuratWrappers)
library(here)


  #load data
  #CVIDagg6.data <- Read10X(data.dir = "Documents/PhD Thesis Work/Data/Single Cell/CVIDagg6_05Dec2022/agg6_filtered_feature_bc_matrix")
CVIDagg6.data <- Read10X(data.dir = 
	"/home/feng/Windows/windowsD/feng/LAB/MSI/maglione/scRNA_analysis1_20220908/aggr6sub/aggr2212_6sbu/outs/count/filtered_feature_bc_matrix")
```

Now, we create Seurat object and clean up the data.

``` {r readData}
CVIDagg6 <- CreateSeuratObject(counts = CVIDagg6.data, project = "CVIDagg6", min.cells = 3, min.features = 200)
ct<-GetAssayData(CVIDagg6, slot="counts")
dat<-GetAssayData(CVIDagg6, slot="data")

#- Add meta.data
mito.genes <- grep(pattern = "^MT-", x = rownames(x = dat), value = TRUE)
percent.mito <- Matrix::colSums(dat[mito.genes, ]) / Matrix::colSums(dat)
CVIDagg6@meta.data$percent.mito <- percent.mito
CVIDagg6@meta.data$sub <- plyr::mapvalues(x = sapply(str_split(rownames(CVIDagg6@meta.data), "[-]"), function(x) x[2]), from = 1:18, to = rep(seq(1,6),c(3,3,3,3,3,3)))
CVIDagg6@meta.data$cvid <- plyr::mapvalues(x = sapply(str_split(rownames(CVIDagg6@meta.data), "[-]"), function(x) x[2]), from = 1:18, to = rep(c("HC","CVID","CVID","HC","CVID","HC"),c(3,3,3,3,3,3)))
CVIDagg6@meta.data$cells <- plyr::mapvalues(x = sapply(str_split(rownames(CVIDagg6@meta.data), "[-]"), function(x) x[2]), from = 1:18, to = rep(c("CD38_high","CD38_mid","CD38_low","CD38_high","CD38_mid","CD38_low","CD38_high","CD38_mid","CD38_low","CD38_high","CD38_low","CD38_mid","CD38_high","CD38_low","CD38_mid","CD38_high","CD38_low","CD38_mid"),c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)))

#CVIDagg6@meta.data %>% head()

#- QC
CVIDagg6 <- subset(CVIDagg6, subset = nFeature_RNA > 200 & nCount_RNA < 40000 & percent.mito < .15)

CVIDagg6 
##An object of class Seurat 
##21188 features across 46878 samples within 1 assay 
##Active assay: RNA (21188 features, 0 variable features)


```
So far, we have done with initial steps. We will next run scaling on
uncorrected data to see whether there are batch effects.

Please DO NOT run the following section, since the code run very long 
time. In this case, we show the code and then jump to load previously 
saved data to do plotting.

```{r, eval=T}
#normalize with default setting
CVIDagg6<-NormalizeData(CVIDagg6, normalization.method = "LogNormalize", scale.factor = 10000)

#find variable features
CVIDagg6 <- FindVariableFeatures(object = CVIDagg6, mean.function = ExpMean, dispersion.function = LogVMR, nfeatures = 3000)

CVIDagg6.orig<-CVIDagg6
#Idents(CVIDagg6.int) <- CVIDagg6.int@meta.data$seurat_clusters
#plot the data before integration/batch correction.
#do scale and PCA
#CVIDagg6.int<-CVIDagg6
CVIDagg6<-ScaleData(CVIDagg6, verbose =T, 
	vars.to.regress = c("nCount_RNA", "percent.mito"), 
	features=rownames(CVIDagg6))
CVIDagg6<-RunPCA(CVIDagg6, npcs = 100, verbose = T)
print(CVIDagg6[["pca"]], dims = 1:10, nfeatures = 5)
#do clustering
ElbowPlot(object = CVIDagg6, ndims = 50)
CVIDagg6<- FindNeighbors(CVIDagg6, reduction = "pca", dims = 1:20)
CVIDagg6<- FindClusters(object = CVIDagg6, #reduction.type = "pca", 
                            dims.use = 1:20, resolution = .6#, #k.param = 30, print.output = TRUE, save.SNN = TRUE
)

#do UMAP
CVIDagg6 <- RunUMAP(object = CVIDagg6, reduction.use = "pca", 
		dims= 1:20, min_dist = .75)

```
We simply load previously saved data and plot them.

```{r plotUncorrected}
#load(file=here("Output","scObjectSeurate.before.RData"))#, CVIDagg6, README)

#png(file="scRNACluster_beforeIntergration.png",width=1000, height=1000)
ggarrange(
 DimPlot(CVIDagg6, reduction = "umap", label=T)
,DimPlot(CVIDagg6, reduction = "umap", label=T, group.by="cvid")
,DimPlot(CVIDagg6, reduction = "umap", label=T, group.by="sub")
,DimPlot(CVIDagg6, reduction = "umap", label=T, group.by="cells")
,nrow=2, ncol=2

)
#dev.off()
```

It seems that we need to do batch correction. In Seurat, it 
is called integration. 
```{r subsetting, eval=T}
####now start doing the subsetting and then integrating 
#   by subsetting. (Note: intergrating among different subject
#		and each subject combining different cell populations )


#start doing the subsetting and then integrating
#   CVIDagg6.orig  this one is normalized!!!
CVIDagg6.ZA03<-subset(CVIDagg6.orig, subset= sub==1)
CVIDagg6.CC33<-subset(CVIDagg6.orig, subset= sub==2)
CVIDagg6.CC22<-subset(CVIDagg6.orig, subset= sub==3)
CVIDagg6.ZA61<-subset(CVIDagg6.orig, subset= sub==4)
CVIDagg6.CC27<-subset(CVIDagg6.orig, subset= sub==5)
CVIDagg6.ZA63<-subset(CVIDagg6.orig, subset= sub==6)

features.names=c("TNFRSF13B","TNFRSF13C", "NFKB1","NFKB2","RELA","RELB", "BCL2", "BCL2L1"
                 ,"BCL2L2", "BCL2A1","MCL1","ICOSLG")
#now we have done the normalization and findVariableFeatures, do directly integration
ancs<-SelectIntegrationFeatures(list(CVIDagg6.ZA03,CVIDagg6.CC33,CVIDagg6.CC22,CVIDagg6.ZA61,CVIDagg6.CC27,CVIDagg6.ZA63), nfeatures=2500) #find the variable features for doing integration
ancs<-union(ancs, features.names) #add ones that we are interested.
CVIDagg6.anchors <- FindIntegrationAnchors(object.list = list(CVIDagg6.ZA03,CVIDagg6.CC33,CVIDagg6.CC22,CVIDagg6.ZA61,CVIDagg6.CC27,CVIDagg6.ZA63), dims = 1:20, anchor.features=ancs)
CVIDagg6.int<- IntegrateData(anchorset = CVIDagg6.anchors, dims = 1:20)

CVIDagg6.int@meta.data %>% View("message")

#do scale and PCA
CVIDagg6.int<-ScaleData(CVIDagg6.int, verbose =T, vars.to.regress = c("nCount_RNA", "percent.mito"), features=rownames(CVIDagg6.int))
CVIDagg6.int<-RunPCA(CVIDagg6.int, npcs = 100, verbose = T)
print(CVIDagg6.int[["pca"]], dims = 1:10, nfeatures = 5)
#do clustering
ElbowPlot(object = CVIDagg6.int, ndims = 50)
CVIDagg6.int<- FindNeighbors(CVIDagg6.int, reduction = "pca", dims = 1:20)
CVIDagg6.int<- FindClusters(object = CVIDagg6.int, #reduction.type = "pca", 
                            dims= 1:20, resolution = .6#, #k.param = 30, print.output = TRUE, save.SNN = TRUE
)

#do UMAP
CVIDagg6.int <- RunUMAP(object = CVIDagg6.int, reduction.use = "pca", dims= 1:20, min_dist = .75)
DimPlot(CVIDagg6.int, reduction = "umap", label=T)
DimPlot(CVIDagg6.int, reduction = "umap", label=T, group.by="sub")
DimPlot(CVIDagg6.int, reduction = "umap", label=T, group.by="cvid")
DimPlot(CVIDagg6.int, reduction = "umap", label=T, group.by="cells")
```
Again, we read the saved data.
```{r readBySub}
#load( file=here("Output","scObjectSeurate.integrateSub.RData"))
#png(file="scRNACluster_IntergrateBySun.png",width=1000, height=1000)
DimPlot(CVIDagg6.int, reduction = "umap", label=T, group.by=c("cvid","cells","sub", "seurat_clusters"))
#dev.off()
```

This is getting better, but still not enough for cell populatoins.

We need to further do it at cell population level.
```{r interByCells, eval=T}
##############################
#	now integrate by cells ###
##############################

#subsetting cells by subject ID
ZA03.high<-subset(CVIDagg6, subset= sub==1&cells=="CD38_high" )
ZA03.mid<-subset(CVIDagg6, subset= sub==1&cells=="CD38_mid" )
ZA03.low<-subset(CVIDagg6, subset= sub==1&cells=="CD38_low" )
CC33.high<-subset(CVIDagg6, subset= sub==2&cells=="CD38_high")
CC33.mid<-subset(CVIDagg6, subset= sub==2&cells=="CD38_mid")
CC33.low<-subset(CVIDagg6, subset= sub==2&cells=="CD38_low")

CC22.high<-subset(CVIDagg6, subset= sub==3&cells=="CD38_high")
CC22.mid<-subset(CVIDagg6, subset= sub==3&cells=="CD38_mid")
CC22.low<-subset(CVIDagg6, subset= sub==3&cells=="CD38_low")

ZA61.high<-subset(CVIDagg6, subset= sub==4&cells=="CD38_high")
ZA61.mid<-subset(CVIDagg6, subset= sub==4&cells=="CD38_mid")
ZA61.low<-subset(CVIDagg6, subset= sub==4&cells=="CD38_low")

CC27.high<-subset(CVIDagg6, subset= sub==5&cells=="CD38_high")
CC27.mid<-subset(CVIDagg6, subset= sub==5&cells=="CD38_mid")
CC27.low<-subset(CVIDagg6, subset= sub==5&cells=="CD38_low")

ZA63.high<-subset(CVIDagg6, subset= sub==6&cells=="CD38_high")
ZA63.mid<-subset(CVIDagg6, subset= sub==6&cells=="CD38_mid")
ZA63.low<-subset(CVIDagg6, subset= sub==6&cells=="CD38_low")

#now do integration
#now we have done the normalization and findVariableFeatures, do directly integration
ancs<-SelectIntegrationFeatures(
	list(ZA03.high, ZA03.mid, ZA03.low, CC33.high,CC33.mid,CC33.low,
		CC22.high,CC22.mid,CC22.low, ZA61.high, ZA61.mid, ZA61.low,
		CC27.high, CC27.mid, CC27.low, ZA63.high, ZA63.mid, ZA63.low	
			)
	, nfeatures=2500) #find the variable features for doing integration
ancs<-union(ancs, features.names) #add ones that we are interested.
CVIDagg6.anchors <- FindIntegrationAnchors(object.list = 
		list(ZA03.high, ZA03.mid, ZA03.low, CC33.high,CC33.mid,CC33.low,
		CC22.high,CC22.mid,CC22.low, ZA61.high, ZA61.mid, ZA61.low,
		CC27.high, CC27.mid, CC27.low, ZA63.high, ZA63.mid, ZA63.low	
			), 
		dims = 1:20, anchor.features=ancs)
CVIDagg6.int<- IntegrateData(anchorset = CVIDagg6.anchors, dims = 1:20)

#do scale and PCA
CVIDagg6.int<-ScaleData(CVIDagg6.int, verbose =T, vars.to.regress = c("nCount_RNA", "percent.mito"), features=rownames(CVIDagg6.int))

CVIDagg6.int<-RunPCA(CVIDagg6.int, npcs = 100, verbose = T)
print(CVIDagg6.int[["pca"]], dims = 1:10, nfeatures = 5)
#do clustering
ElbowPlot(object = CVIDagg6.int, ndims = 50)
CVIDagg6.int<- FindNeighbors(CVIDagg6.int, reduction = "pca", dims = 1:20)
CVIDagg6.int<- FindClusters(object = CVIDagg6.int, #reduction.type = "pca", 
                            dims= 1:20, resolution = .6#, #k.param = 30, print.output = TRUE, save.SNN = TRUE
)

#do UMAP
CVIDagg6.int <- RunUMAP(object = CVIDagg6.int, reduction.use = "pca", dims= 1:20, min_dist = .75)

```

Read the data again,
```{r readByCells}
#load(file=here("Output","scObjectSeurate.integrateCells.RData"))

#png(file="scRNACluster_IntergrateByCells.png",width=1000, height=1000)
DimPlot(CVIDagg6.int, reduction = "umap", label=T, group.by=c("cvid","cells","sub", "seurat_clusters"))
#dev.off()
#README="Batch correction/integration by cells with seurat"
#README =paste0(README,"See code and details in CVIDagg6_SeuratPipeline_FF_v1.0.R")
```
Still not perfect. I want to try MNN (mutual near neighbors).

```{r mnn, eval=T}
###############################
###             MNN batch correction
#what to do next? need to do using scRNASeq and bachelor
#It can be used on seurat objects
#

CVIDagg6.int<-RunFastMNN(object.list=
	list(ZA03.high, ZA03.mid, ZA03.low, CC33.high,CC33.mid,CC33.low,
		CC22.high,CC22.mid,CC22.low, ZA61.high, ZA61.mid, ZA61.low,
		CC27.high, CC27.mid, CC27.low, ZA63.high, ZA63.mid, ZA63.low	
			),
	)
CVIDagg6.int <-RunUMAP(CVIDagg6.int, reduction = "mnn", 
	dims = 1:20, min.dist=0.75)
CVIDagg6.int <- FindNeighbors(CVIDagg6.int, reduction = "mnn", dims = 1:20)
CVIDagg6.int <- FindClusters(CVIDagg6.int,dims= 1:20, resolution = .6)

```{r readMNN}
#load(file=here("Output","scObjectSeurate.integrateCellsMNN.RData"))


#png(file="scRNACluster_IntergrateByCellsMNN.png",width=1000, height=1000)
DimPlot(CVIDagg6.int, group.by = c("cvid", "cells", "sub","ident") )
#dev.off()
#README="Batch correction/integration by cells with seurat using MNN bachelor"
#README =paste0(README,"See code and details in CVIDagg6_SeuratPipeline_FF_v1.0.R")
```

Now, it seems that this last one is good enough.


I want to use the corrected data to do cell cyle.
#cc.genes is in seurat library now.
```{r cellcycle}
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes
DefaultAssay(CVIDagg6.int)<-"mnn.reconstructed"
CVIDagg6.int<-CellCycleScoring(CVIDagg6.int, 
	s.features = s.genes, 
	g2m.features = g2m.genes, 
	set.ident = TRUE)
head(CVIDagg6.int)

DimPlot(CVIDagg6.int, group.by = c("cvid", "cells", "sub","Phase") )

```

Done!!

```{r sessioninfo}
sessionInfo()
```